/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.11.0
 * Tue, 02 Dec 2025 12:10:19 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();
_pGlob.css3Objects = new WeakMap();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
        
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    class MediaHTML5 {
        constructor() {
            this.source = null;
        }
    
        load(url, isVideo) {
            if (isVideo) {
                this.source = document.createElement('video');
                this.source.playsInline = true;
                this.source.preload = 'auto';
                this.source.autoload = true;
                this.source.crossOrigin = 'anonymous';
            } else {
                this.source = document.createElement('audio');
            }
    
            this.source.src = url;
            return this;
        }
    
        play() {
            this.source.play();
        }
    
        pause() {
            this.source.pause();
        }
    
        stop() {
            this.source.pause();
            this.source.currentTime = 0;
        }
    
        rewind() {
            this.source.currentTime = 0;
        }
    
        setPlaybackTime(time) {
            this.source.currentTime = time
        }
    
        getPlaybackTime() {
            return this.source.currentTime;
        }
    
        getDuration() {
            return this.source.duration;
        }
    
        setPlaybackRate(rate) {
            this.source.playbackRate = rate;
        }
    
        isPlaying() {
            return this.source.duration > 0 && !this.source.paused;
        }
    
        setLoop(looped) {
            this.source.loop = looped;
        }
    
        setVolume(volume) {
            this.source.volume = volume;
        }
    
        setMuted(muted) {
            this.source.muted = muted;
        }
    
        toPositional() {
            if (!(this.audio instanceof v3d.PositionalAudio)) {
                const posAudio = new v3d.PositionalAudio(new v3d.AudioListener());
                posAudio.setMediaElementSource(this.source);
                this.audio = posAudio;
            }
            return this.audio;
        }
    }
        
    class AudioWebAudio {
        constructor() {
            this.audio = new v3d.Audio(new v3d.AudioListener());
    
            this._muted = false;
            this._volume = 1;
        }
    
        load(url) {
            const scope = this;
    
            const xhr = new XMLHttpRequest();
            xhr.open('GET', url);
            xhr.responseType = 'arraybuffer';
    
            xhr.onload = function(e) {
                if (this.status === 200) {
                    // new promise-based syntax is not currently supported in Safari
                    scope.audio.context.decodeAudioData(this.response, function(decodedData) {
                        scope.audio.setBuffer(decodedData);
                    });
                }
            }
    
            xhr.send();
            return this;
        }
    
        play() {
            if (this.audio.buffer === null) return;
            this.audio.play();
        }
    
        pause() {
            this.audio.pause();
        }
    
        stop() {
            if (this.audio.buffer === null || this.audio.source === null) return;
            this.audio.stop();
        }
    
        rewind() {
            if (this.audio.buffer === null || this.audio.source === null) return;
    
            const isPlaying = this.audio.isPlaying;
            this.audio.stop();
            if (isPlaying) {
                this.audio.play();
            }
        }
    
        setPlaybackTime(time) {
            // TODO: not easy with WebAudio
        }
    
        getPlaybackTime() {
            // TODO: not easy with WebAudio
            return 0;
        }
    
        getDuration() {
            return (this.audio.buffer === null) ? 0 : this.audio.buffer.duration;
        }
    
        setPlaybackRate(rate) {
            this.audio.setPlaybackRate(rate);
        }
    
        isPlaying() {
            return this.audio.isPlaying;
        }
    
        setLoop(looped) {
            this.audio.setLoop(looped);
        }
    
        setVolume(volume) {
            this._volume = volume;
            if (!this._muted) {
                this.audio.setVolume(volume);
            }
        }
    
        setMuted(muted) {
            this._muted = muted;
            this.audio.setVolume(muted ? 0 : this._volume);
        }
    
        toPositional() {
            if (!(this.audio instanceof v3d.PositionalAudio)) {
                const posAudio = new v3d.PositionalAudio(this.audio.listener);
                posAudio.fromAudio(this.audio);
                this.audio = posAudio;
            }
            return this.audio;
        }
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
        
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function removeObject(obj, objName) {
        if (obj.isClippingPlaneObject)
            // COMPAT: < 4.10, new puzzles, old engine
            if (v3d.SceneUtils.removeClipPlanesFromMats)
                v3d.SceneUtils.removeClipPlanesFromMats(obj, appInstance.scene);
    
        obj.parent.remove(obj);
    
        // remove object and its children from cache
        _pGlob.objCache.delete(objName);
    
        obj.traverse(child => {
            _pGlob.objCache.delete(child.name);
        });
    }
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function getObjectUUID(obj) {
        // auto-generated from a multi-material object, use parent UUID instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.uuid;
        } else {
            return obj.uuid;
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        // css renderer prevents interacting with canvas, in that case we assign events on container
        const elem = appInstance.cssRenderer ? appInstance.container : appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectAmongObjects(objNameToCheck, objUUIDToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        // COMPAT: <4.10, when calling with 2 arguments
        if (Array.isArray(objUUIDToCheck)) {
            objNames = objUUIDToCheck;
            objUUIDToCheck = objNameToCheck;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            const objName = objNames[i];
    
            // COMPAT: < 4.10 (4.9), old engine, new puzzles
            const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
            if ((isID ? objUUIDToCheck : objNameToCheck) === objName) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objName);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        // if parent referred by UUID, compare children also by UUID
                        if (isID ? (objUUIDToCheck === obj.children[j].uuid) : (objNameToCheck === obj.children[j].name)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function xrTraverseNonControllers(obj, callback) {
        if (obj.name.startsWith('XR_CONTROLLER_')) {
            return;
        }
    
        callback(obj);
    
        const children = obj.children;
        for (let i = 0, l = children.length; i < l; i++) {
            xrTraverseNonControllers(children[i], callback);
        }
    };
        
    function xrGetIntersections(controller) {
        controller.updateWorldMatrix(true, false);
    
        _pGlob.mat4Tmp.identity().extractRotation(controller.matrixWorld);
    
        const objList = [];
        xrTraverseNonControllers(appInstance.scene, obj => objList.push(obj));
    
        const raycaster = new v3d.Raycaster();
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(_pGlob.mat4Tmp);
    
        return raycaster.intersectObjects(objList, false);
    }
        
    function xrOnSelect(event) {
        if (!_pGlob.objClickInfo) {
            return;
        }
    
        const controller = event.target;
        const intersections = xrGetIntersections(controller);
    
        if (intersections.length > 0) {
            const intersection = intersections[0];
            const obj = intersection.object;
    
            _pGlob.objClickInfo.forEach(info => {
                const objName = getObjectName(obj);
                const objUUID = getObjectUUID(obj);
    
                // save the object for the pickedObject block
                _pGlob.pickedObject = info.useID ? objUUID : objName;
    
                const isPicked = obj && isObjectAmongObjects(objName, objUUID,
                        retrieveObjectNames(info.objSelector));
                info.callbacks[isPicked ? 0 : 1]();
            });
        } else {
            // missed
            _pGlob.objClickInfo.forEach(info => info.callbacks[1]());
        }
    }
        
    function unbindListener(target, type, listener, optionsOrUseCapture) {
        const index = _pGlob.eventListeners.findIndex(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
        });
    
        if (index !== -1) {
            target.removeEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.splice(index, 1);
        }
    }
        
    function xrGetInputSource(controller) {
        if (controller && controller.userData.inputSource) {
            return controller.userData.inputSource;
        } else {
            return null;
        }
    };
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    const LIST_NONE = '<none>';
        
    function getMaterialEditableValues(matName) {
        const mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
        if (!mat) {
            return [];
        }
    
        if (mat.isMeshNodeMaterial) {
            return Object.keys(mat.nodeValueMap);
        } else if (mat.isMeshStandardMaterial) {
            return ['metalness', 'roughness', 'bumpScale', 'emissiveIntensity',
                    'envMapIntensity'];
        } else {
            return [];
        }
    }
        
    function generateUniqueName(name, isUniqueCb) {
        let uniqueName = name;
    
        if (isUniqueCb !== undefined) {
            while (!isUniqueCb(uniqueName)) {
                const r = uniqueName.match(/^(.*?)(\d+)$/);
                if (!r) {
                    uniqueName += '2';
                } else {
                    uniqueName = r[1] + (Number.parseInt(r[2], 10) + 1);
                }
            }
        }
    
        return uniqueName;
    }
        
    function generateUniqueObjectName(name) {
        return generateUniqueName(name, name => !Boolean(getObjectByName(name)));
    }

    return {
        getElement, getElements, MediaHTML5, AudioWebAudio,
        getObjectByName, bindListener, getSceneAnimFrameRate, getSceneByAction,
        retrieveObjectNames, removeObject, getObjectName, getObjectUUID,
        initObjectPicking, isObjectAmongObjects, xrGetIntersections, xrOnSelect,
        unbindListener, xrGetInputSource, transformCoordsSpace, getSceneCoordSystem,
        transformEulerV3dToBlenderShortest, RotationInterface, LIST_NONE, getMaterialEditableValues,
        generateUniqueObjectName,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["VR_INIT"] = VR_INIT;
this.procedures["put_in_mixer"] = put_in_mixer;
this.procedures["randomize_track"] = randomize_track;
this.procedures["get_fruit"] = get_fruit;

var source, fruit, hand, fruits_in_hands, VR_mode, sound_lock, mixer_place, current_track, fruits_in_mixer, sound_on, mixing, move_forward, fruits_in_mixer_count, move_side, dir_vector_forward, cup_full, dir_vector_side, mixer_opened, dir_vector, smoothie_hue, i, move_speed, ray_cast_position, raycast_result;

// createCSSRule puzzle
function createCSSRule(cssRule, cssRuleCont, isParent, mediaRule) {
    var style = document.createElement('style');
    style.type = 'text/css';
    if (mediaRule) {
        style.innerHTML = `@media ${mediaRule} { ${cssRule} { ${cssRuleCont} } }`;
    } else {
        style.innerHTML = `${cssRule} { ${cssRuleCont} }`;
    }

    var styles = (isParent) ? parent.document.getElementsByTagName('head')[0] :
                              document.getElementsByTagName('head')[0];
    styles.appendChild(style)
}

// addHTMLElement puzzle
function addHTMLElement(elemType, id, mode, targetId, isParent) {
    const win = isParent ? window.parent : window;

    const elem = win.document.createElement(elemType);
    if (id !== '')
        elem.id = id;

    const targetElem = PzLib.getElement(targetId, isParent);
    if (targetElem instanceof win.Element) {
        switch (mode) {
            case 'TO':
                targetElem.appendChild(elem);
                break;
            case 'BEFORE':
                targetElem.insertAdjacentElement('beforebegin', elem);
                break;
            case 'AFTER':
                targetElem.insertAdjacentElement('afterend', elem);
                break;
        }

        _pGlob.htmlElements.add(elem);
    } else
        console.error('add HTML element puzzle: Invalid element "' + targetId + '"');
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// checkVRMode puzzle
function checkVRMode(availableCb, unAvailableCb) {
    v3d.Detector.checkWebXR('immersive-vr', availableCb, unAvailableCb);
}

// loadMedia puzzle
function loadMedia_HTML5(url) {

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new PzLib.MediaHTML5().load(url);
    }
    return elems[url];
}

// volume puzzle
function volume(mediaElem, volume) {
    const mediaElems = (Array.isArray(mediaElem) ? mediaElem : [mediaElem]).filter(elem => elem);

    volume = Number(volume);
    if (Number.isNaN(volume)) {
        return;
    }

    mediaElems.forEach(mediaElem => {
        mediaElem.setVolume(v3d.MathUtils.clamp(volume, 0.0, 1.0));
    });
}

// soundPositionalSpeaker puzzle
function soundPositionalSpeaker(mediaElem, objSelector, refDistance, rolloffFactor) {

    const targetObj = PzLib.getObjectByName(objSelector);
    if (!targetObj)
        return;

    const mediaElems = (Array.isArray(mediaElem) ? mediaElem : [mediaElem]).filter(elem => elem);
    mediaElems.forEach(mediaElem => {
        let posAudio = mediaElem.toPositional();
        if (!posAudio)
            return;

        posAudio.removeFromParent();
        targetObj.add(posAudio);

        posAudio.setRefDistance(refDistance);
        posAudio.setRolloffFactor(rolloffFactor)

        posAudio.listener.removeFromParent();
        appInstance.getCamera().add(posAudio.listener);
    });
}

// loadMedia puzzle
function loadMedia_WebAudio(url) {
    if (!v3d.Detector.checkWebAudio()) {
        if (!_pGlob.noWebAudioReported) {
            _pGlob.noWebAudioReported = true;
            console.error('load sound: Web Audio API not supported');
        }
        return null;
    }

    var elems = _pGlob.mediaElements;
    if (!(url in elems)) {
        elems[url] = new PzLib.AudioWebAudio().load(url);
    }
    return elems[url];
}

// playSound puzzle
function playSound(mediaElem, loop) {
    const mediaElems = (Array.isArray(mediaElem) ? mediaElem : [mediaElem]).filter(elem => elem);
    mediaElems.forEach(mediaElem => {
        mediaElem.setLoop(loop);
        if (mediaElem.audio)
            mediaElem.audio.context.resume();
        mediaElem.play();
    });
}

_pGlob.animMixerCallbacks = [];

const initAnimationMixer = function() {

    function onMixerFinished(e) {
        const cb = _pGlob.animMixerCallbacks;
        const found = [];
        for (let i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (let i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;

        let scene, frameRate, timeScale, callbacks;

        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();

                if (loop == 'AUTO') {
                    // COMPAT: < 4.10, old engine, new puzzles (no autoParams)
                    if (action.autoParams) {
                        action.loop = action.autoParams.loop;
                        action.repetitions = action.autoParams.repetitions;
                    } else {
                        action.repetitions = Infinity;
                    }
                } else {
                    action.loop = v3d[loop];
                    action.repetitions = Infinity;
                }

                scene = PzLib.getSceneByAction(action);
                frameRate = PzLib.getSceneAnimFrameRate(scene);
                timeScale = Math.abs(parseFloat(speed));

                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                callbacks = _pGlob.animMixerCallbacks;
                let found = false;
                for (let j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            callbacks = _pGlob.animMixerCallbacks;
            for (let j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--;
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            scene = PzLib.getSceneByAction(action);
            frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// dictGet puzzle
function dictGet(dict, key, defaultValue) {
    if (dict && typeof dict == 'object')
        return (key in dict) ? dict[key] : defaultValue;
}

// removeObject puzzles
function removeObject(objSelector) {
    const objNames = PzLib.retrieveObjectNames(objSelector);

    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i]
        if (!objName)
            continue;
        const obj = PzLib.getObjectByName(objName);
        if (!obj || !obj.parent)
            continue;

        PzLib.removeObject(obj, objName);

        if (_pGlob.css3Objects.has(obj)) {
            const cssObj = _pGlob.css3Objects.get(obj);
            PzLib.removeObject(cssObj, cssObj.name);
            _pGlob.css3Objects.delete(obj);
        }
    }
}

// dictRemove puzzle
function dictRemove(dict, key) {
    if (dict && typeof dict == 'object')
        delete dict[key];
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// onAnimationFrameDo puzzle

_pGlob.animTriggers = [];

function processAnimTriggers() {
    _pGlob.animTriggers.forEach(function(animTrigger) {
        const action = animTrigger.action;
        if (action.timeScale > 0 && action.time >= animTrigger.time && animTrigger.time > animTrigger.prevTime)
            animTrigger.callback();

        else if (action.timeScale < 0 && action.time <= animTrigger.time && animTrigger.time < animTrigger.prevTime)
            animTrigger.callback();

        animTrigger.prevTime = action.time;
    });
}

appInstance.renderCallbacks.push(processAnimTriggers);
if (PL.editorRenderCallbacks)
    PL.editorRenderCallbacks.push([appInstance, processAnimTriggers]);

function onAnimationFrameDo(animSelector, frame, callback) {
    if (!animSelector)
        return;
    // input can be either single obj or array of objects
    if (typeof animSelector == "string")
        animSelector = [animSelector];

    for (let i = 0; i < animSelector.length; i++) {
        const animName = animSelector[i];
        if (animName) {
            const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
            if (!action)
                continue;

            const scene = PzLib.getSceneByAction(action);
            const frameRate = PzLib.getSceneAnimFrameRate(scene);

            _pGlob.animTriggers.push({
                action: action,
                time: frame ? frame/frameRate : 0,
                prevTime: action.time,
                callback: callback
            });

        }
    }

}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, useID, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        useID: useID,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        let isPicked = false;

        const maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (let i = 0; i < maxIntersects; i++) {
            const obj = intersects[i].object;

            const objName = PzLib.getObjectName(obj);
            const objUUID = PzLib.getObjectUUID(obj);
            const objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objUUID, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = useID ? objUUID : objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// enterVRMode puzzle
function enterVRMode(refSpace, enterCb, exitCb, unAvailableCb) {

    var DEFAULT_DEPTH = 10;

    var _rayReticleDepth = [];
    var _hoveredObjects = [];

    function onControllerHover() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            var intersections = PzLib.xrGetIntersections(controller);

            if (intersections.length > 0) {
                var intersection = intersections[0];
                var obj = intersection.object;
                _rayReticleDepth[i] = intersection.distance;
            } else {
                var obj = null;
                _rayReticleDepth[i] = DEFAULT_DEPTH;
            }

            controller.children.forEach(function(child) {
                if (child.name.indexOf('_RAY') > -1) {
                    child.scale.z = _rayReticleDepth[i];
                } else if (child.name.indexOf('_RETICLE') > -1) {
                    // reduces crossing artefacts
                    child.position.z = -0.95 * _rayReticleDepth[i];
                }
            });

            var prevHovered = _hoveredObjects[i];
            var currHovered = obj ? PzLib.getObjectName(obj) : '';

            if (prevHovered == currHovered) {
                continue;
            }

            // first - all "out" callbacks, then - all "over"
            _pGlob.objHoverInfo.forEach(function(el) {
                if (PzLib.isObjectAmongObjects(prevHovered, PzLib.retrieveObjectNames(el.objSelector))) {
                    // ensure the correct value of the hoveredObject block
                    _pGlob.hoveredObject = prevHovered;
                    el.callbacks[1]();
                }
            });

            _pGlob.objHoverInfo.forEach(function(el) {
                if (PzLib.isObjectAmongObjects(currHovered, PzLib.retrieveObjectNames(el.objSelector))) {
                    // ensure the correct value of the hoveredObject block
                    _pGlob.hoveredObject = currHovered;
                    el.callbacks[0]();
                }
            });

            _hoveredObjects[i] = currHovered;
        }
    }

    switch (refSpace) {
        case 'SITTING':
            var referenceSpace = 'local-floor';
            break;
        case 'WALKING':
            var referenceSpace = 'unbounded';
            break;
        case 'ORIGIN':
            var referenceSpace = 'local';
            break;
        case 'ROOM':
            var referenceSpace = 'bounded-floor';
            break;
        case 'VIEWER':
            var referenceSpace = 'viewer';
            break;
        default:
            console.error('enter VR mode puzzle: Wrong VR reference space');
            return;
    }

    appInstance.initWebXR('immersive-vr', referenceSpace, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            // clicks
            PzLib.bindListener(controller, 'select', PzLib.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                PzLib.bindListener(controller, pair[0], pair[1]);
            });
        }

        // hovers
        if (_pGlob.objHoverInfo && _pGlob.objHoverInfo.length && appInstance.renderCallbacks.indexOf(onControllerHover) == -1)
            appInstance.renderCallbacks.push(onControllerHover);

        _pGlob.xrSessionAcquired = true;

        enterCb();

    }, unAvailableCb, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            PzLib.unbindListener(controller, 'select', PzLib.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                PzLib.unbindListener(controller, pair[0], pair[1]);
            });
        }

        var cbIdx = appInstance.renderCallbacks.indexOf(onControllerHover);
        if (cbIdx != -1)
            appInstance.renderCallbacks.splice(cbIdx, 1);

        _pGlob.xrSessionAcquired = false;

        // to cleanup XR_CAMERA_CONTROL_OBJECT and XR controllers
        _pGlob.objCache.clear();

        exitCb();
    });
}

// Describe this function...
function VR_INIT() {
    enterVRMode('SITTING', function() {
        VR_mode = true;
    }, function() {
        VR_mode = false;
    }, function() {});
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// xrControllerProp puzzle
function xrControllerProp(prop) {

    if (_pGlob.xrSessionAcquired) {
        var controller = appInstance.xrControllers[_pGlob.gamepadIndex || 0];
        var inputSource = PzLib.xrGetInputSource(controller);
    } else {
        var controller = undefined;
        var inputSource = undefined;
    }

    switch (prop) {
    case 'OBJECT':
        if (controller)
            return controller.name;
        else
            return '';

    case 'RAY_RETICLE':
        if (controller && controller.children.length)
            return controller.children[0].name;
        else
            return '';

    case 'HANDEDNESS':
        if (controller && inputSource)
            return inputSource.handedness;
        else
            return '';

    case 'TARGET_RAY_MODE':
        if (controller && inputSource)
            return inputSource.targetRayMode;
        else
            return '';

    case 'PROFILES':
        if (controller && inputSource)
            return inputSource.profiles;
        else
            return [];

    case 'GAMEPAD_INDEX':
        if (controller && inputSource && inputSource.gamepad)
            return _pGlob.gamepadIndex || 0;
        else
            return 0;
    }

}

// getGamepadProp puzzle
function getGamepadProp(index, prop, controlIndex) {

    if (_pGlob.xrSessionAcquired) {
        var controller = appInstance.xrControllers[index];

        if (controller && controller.userData.inputSource &&
                controller.userData.inputSource.gamepad)
            var gamepad = controller.userData.inputSource.gamepad;
        else
            var gamepad = undefined;

    } else {
        var gamepad = navigator.getGamepads()[index];
    }

    switch (prop) {
    case 'AXIS':
        if (gamepad)
            return (gamepad.axes[controlIndex] || 0);
        else
            return 0;

    case 'BUTTON':
        if (gamepad) {
            var button = gamepad.buttons[controlIndex];

            if (button)
                return button.pressed;
            else
                return false;
        } else {
            return false;
        }

    case 'ANALOG_BUTTON':
        if (gamepad) {
            var button = gamepad.buttons[controlIndex];

            if (button)
                return button.value;
            else
                return 0.0;
        } else {
            return 0.0;
        }

    case 'ID':
        if (gamepad)
            return gamepad.id;
        else
            return '';

    case 'CONNECTION_STATUS':
        if (gamepad)
            return gamepad.connected;
        else
            return false;

    case 'TIMESTAMP':
        if (gamepad)
            return gamepad.timestamp;
        else
            return 0.0;

    case 'MAPPING':
        if (gamepad)
            return gamepad.mapping;
        else
            return '';

    case 'DEBUG_INFO':
        if (gamepad) {

            var axes = gamepad.axes;
            var axesValues = []

            for (var i = 0; i < axes.length; i++) {
                axesValues.push(Math.round(axes[i] * 1000) / 1000);
            }

            var buttons = gamepad.buttons;
            var btnsPressed = [];
            var btnsValues = [];

            for (var i = 0; i < buttons.length; i++) {
                btnsPressed.push(buttons[i].pressed ? '☑' : '☐');
                btnsValues.push(Math.round(buttons[i].value * 1000) / 1000);
            }

            return 'Index: ' + index + '\n' +
                   'Connected: ' + (gamepad.connected ? 'Yes' : 'No') + '\n' +
                   'ID: ' + (gamepad.id ? gamepad.id : 'N/A') + '\n' +
                   'Axes: ' + String(axesValues) + '\n' +
                   'Buttons: ' + String(btnsPressed) + '\n' +
                   'Analog Buttons: ' + String(btnsValues) + '\n' +
                   'Timestamp: ' + (gamepad.timestamp ? gamepad.timestamp.toFixed(3) : 0);
        } else {
            return 'Gamepad not available';
        }
    }

}

// getActiveCamera puzzle
function getActiveCamera() {
    var camera = appInstance.getCamera();
    return camera.name;
}

// getObjDirection puzzle
function getObjDirection(objName, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var dir = obj.getWorldDirection(_pGlob.vec3Tmp);

    var coordSystem = PzLib.getSceneCoordSystem();
    PzLib.transformCoordsSpace(dir, 'Y_UP_RIGHT', coordSystem);

    switch (coord) {
    case 'X':
        return dir.x;
    case 'Y':
        return dir.y;
    case 'Z':
        return dir.z;
    case 'XYZ':
        return dir.toArray();
    case 'HORIZONTAL':
        switch (coordSystem) {
        case 'Y_UP_RIGHT':
            dir.y = 0;
            dir.normalize();
            return [dir.x, 0, dir.z];
        default:
            dir.z = 0;
            dir.normalize();
            return [dir.x, dir.y, 0];
        }
    default:
        console.error("get object direction puzzle: Wrong coords");
        return;
    }
};

// createVector puzzle
function createVector(x, y, z) {
    return [x, y, z];
};

// vectorMath puzzle
function vectorMath(vec1, operation, vec2) {

    vec1 = _pGlob.vec3Tmp.fromArray(vec1);

    if (Array.isArray(vec2)) {
        vec2 = _pGlob.vec3Tmp2.fromArray(vec2);
    } else if (['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE'].indexOf(operation) > -1) {
        vec2 = _pGlob.vec3Tmp2.setScalar(vec2);
    } else {
        console.error('vector math puzzle: Invalid argument, scalars are not allowed for ' + operation.toLowerCase() + ' operation');
        return;
    }

    switch (operation) {
    case 'ADD':
        return vec1.add(vec2).toArray();
    case 'SUBTRACT':
        return vec1.sub(vec2).toArray();
    case 'MULTIPLY':
        return vec1.multiply(vec2).toArray();
    case 'DIVIDE':
        return vec1.divide(vec2).toArray();
    case 'DOT':
        return vec1.dot(vec2);
    case 'CROSS':
        return vec1.cross(vec2).toArray();
    case 'ROTATE':
        var euler = _pGlob.eulerTmp;
        vec2.multiplyScalar(Math.PI/180);
        return vec1.applyEuler(euler.setFromVector3(vec2)).toArray();
    default:
        console.error('vector math puzzle: Wrong operation');
        return;
    }
};

// xrCameraControlObject puzzle
function xrCameraControlObject() {
    const camera = appInstance.getCamera();
    if (camera && camera.parent && !camera.parent.isScene)
        return camera.parent.name;
    else
        return '';
}

// getObjTransform puzzle
function getObjTransform(objName, isWorldSpace, mode, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = PzLib.getSceneCoordSystem();

    var transformVal;

    if (isWorldSpace && obj.parent) {
        if (mode === 'position') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldPosition(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'rotation') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldEuler(_pGlob.eulerTmp, 'XYZ'), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'scale') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldScale(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        }

    } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);

    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = PzLib.RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);

    } else {
        transformVal = PzLib.transformCoordsSpace(obj[mode].clone(),
                'Y_UP_RIGHT', coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}

// setVectorValue puzzle
function setVectorValue(vector, valueName, value) {
    switch (valueName) {
    case 'X':
        vector[0] = value;
        break;
    case 'Y':
        vector[1] = value;
        break;
    case 'Z':
        vector[2] = value;
        break;
    case 'LENGTH':
        _pGlob.vec3Tmp.fromArray(vector).setLength(value).toArray(vector);
        break;
    }
}

// raycast puzzle
const _raycastRaycasterTmp = new v3d.Raycaster();

function raycast(fromPosObj, dir, intersectObjsSelector, onlyVisible) {

    if (!fromPosObj || !dir) {
        console.error('raycast puzzle: Missing input');
        return [];
    }

    let from;

    if (Array.isArray(fromPosObj)) {
        from = _pGlob.vec3Tmp.fromArray(fromPosObj);
        from = PzLib.transformCoordsSpace(from, PzLib.getSceneCoordSystem(),
                'Y_UP_RIGHT');
    } else {
        const posObj = PzLib.getObjectByName(fromPosObj);
        if (!posObj) {
            console.error('raycast puzzle: Raycast object not found');
            return []
        }
        from = posObj.getWorldPosition(_pGlob.vec3Tmp);
    }

    dir = _pGlob.vec3Tmp2.fromArray(dir);
    dir = PzLib.transformCoordsSpace(dir, PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');

    let objs;

    if (intersectObjsSelector === '' || intersectObjsSelector === PzLib.LIST_NONE) {

        objs = [appInstance.scene];

    } else {

        objs = PzLib.retrieveObjectNames(intersectObjsSelector).map(function(objName) {
            return PzLib.getObjectByName(objName);
        });

    }

    if (objs.length) {

        const raycaster = _raycastRaycasterTmp;

        raycaster.params.checkVisibility = onlyVisible;
        raycaster.set(from, dir);
        const intersects = raycaster.intersectObjects(objs);

        for (let i = 0; i < intersects.length; i++) {
            const int = intersects[i];

            int.object = PzLib.getObjectName(int.object);
            int.point = PzLib.transformCoordsSpace(int.point, 'Y_UP_RIGHT',
                    PzLib.getSceneCoordSystem()).toArray();

            if (int.face) {
                int.normal = PzLib.transformCoordsSpace(int.face.normal,
                        'Y_UP_RIGHT', PzLib.getSceneCoordSystem()).toArray();
            }

            if (int.uv) {
                int.uv = int.uv.toArray();
            }

            delete int.face;
            delete int.faceIndex;

        }

        return intersects;
    } else {
        return [];
    }
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset) {
    const x = vector[0];
    const y = vector[1];
    const z = vector[2];

    if (isNaN(x) || isNaN(y) || isNaN(z)) {
        console.error('set transform puzzle: Invalid transform');
        return;
    }

    const objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    const inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''), Number(z !== ''));
    const coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    const coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (let i = 0; i < objNames.length; i++) {

        const objName = objNames[i];
        if (!objName) continue;

        const obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            const euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            const rotUI = PzLib.RotationInterface.initObject(obj);
            const euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);
        }

        obj.updateWorldMatrix(false, true);
    }

}

// traverseControllers puzzle
function traverseControllers(callback) {
    if (_pGlob.xrSessionAcquired) {
        for (var i = 0; i < appInstance.xrControllers.length; i++) {

            var controller = appInstance.xrControllers[i];
            var inputSource = PzLib.xrGetInputSource(controller);

            if (controller && inputSource) {
                _pGlob.gamepadIndex = i;
                callback();
            }
        }
    }
}

// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == 'function') {
        appInstance.renderCallbacks.push(callback);
        if (PL.editorRenderCallbacks)
            PL.editorRenderCallbacks.push([appInstance, callback]);
    }
}

function mathRandomInt(a, b) {
  if (a > b) {
    // Swap a and b to ensure a is smaller.
    var c = a;
    a = b;
    b = c;
  }
  return Math.floor(Math.random() * (b - a + 1) + a);
}

// makeParent puzzle
function makeParent(objName, targetObjName) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;
    if (targetObjName && targetObjName !== PzLib.LIST_NONE) {
        var targetObj = PzLib.getObjectByName(targetObjName);
        if (!targetObj)
            return;
    } else {
        obj.traverseAncestors(function(ancObj) {
            if (ancObj.type == "Scene")
                targetObj = ancObj;
        });
    }
    var matOffset = new v3d.Matrix4();
    matOffset.copy(targetObj.matrixWorld).invert();
    matOffset.multiply(obj.matrixWorld);
    matOffset.decompose(obj.position, obj.quaternion, obj.scale);
    targetObj.add(obj);

    obj.updateWorldMatrix(false, true);
}

// snapToObject puzzle
function snapToObject(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;
    var obj = PzLib.getObjectByName(objName);
    var targetObj = PzLib.getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;
    obj.copyTransform(targetObj);
    obj.updateWorldMatrix(false, true);
}

// dictSet puzzle
function dictSet(dict, key, value) {
    if (dict && typeof dict == 'object')
        dict[key] = value;
}

// setMaterialValue puzzle
function setMaterialValue(matName, valName, value) {

    var values = PzLib.getMaterialEditableValues(matName);
    if (values.indexOf(valName) < 0)
        return;

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var valIdx = mat.nodeValueMap[valName];
            mat.nodeValue[valIdx] = Number(value);
        } else
            mat[valName] = Number(value);

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

// getAnimations puzzle
function getAnimations(objSelector, useID) {
    const objNames = PzLib.retrieveObjectNames(objSelector);

    const animations = [];
    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i];
        if (!objName)
            continue;

        // COMPAT: < 4.10
        if (v3d.MathUtils.checkUUID && v3d.SceneUtils.getAnimationActionByObjectUUID && v3d.MathUtils.checkUUID(objName)) {
            const action = v3d.SceneUtils.getAnimationActionByObjectUUID(appInstance, objName);
            if (action)
                animations.push(useID ? action.getClip().uuid : action.getClip().name);
        // COMPAT: < 4.10
        } else if (v3d.SceneUtils.getAnimationActionsByName && useID) {
            // if name provided and useID checked, there might be several IDs for the same name
            const actions = v3d.SceneUtils.getAnimationActionsByName(appInstance, objName);
            actions.forEach(action => {
                animations.push(action.getClip().uuid);
            });
        } else {
            // objName == animName
            const action = v3d.SceneUtils.getAnimationActionByName(appInstance, objName);
            if (action)
                animations.push(useID ? action.getClip().uuid : action.getClip().name);
        }
    }
    return animations;
}

// Describe this function...
function put_in_mixer(source) {
    mixer_place = 'mixer_place_' + String(mathRandomInt(1, 4));
    if ((fruits_in_mixer && typeof fruits_in_mixer == 'object' ? fruits_in_mixer.hasOwnProperty(mixer_place) : false) == false) {
        makeParent(dictGet(fruits_in_hands, source), '<none>');
        snapToObject(dictGet(fruits_in_hands, source), mixer_place);
        makeParent(dictGet(fruits_in_hands, source), mixer_place);
        dictSet(fruits_in_mixer, mixer_place, dictGet(fruits_in_hands, source));
        if (String(dictGet(fruits_in_mixer, mixer_place)).charAt(0) == 'a') {
            smoothie_hue = smoothie_hue + 0.025;
        } else if (String(dictGet(fruits_in_mixer, mixer_place)).charAt(0) == 'b') {
        } else if (String(dictGet(fruits_in_mixer, mixer_place)).charAt(0) == 'o') {
            smoothie_hue = smoothie_hue - 0.025;
        }
        setMaterialValue('smoothie_in_mixer', 'hue', smoothie_hue);
        if (cup_full) {
            operateAnimation('PLAY', 'smoothie_in_cup', 0, 60, 'LoopOnce', 1, function() {
                changeVis('smoothie_in_cup', false);
                cup_full = false;
            }, true);
        }
        setMaterialValue('smoothie_in_cup', 'hue', smoothie_hue);
        dictRemove(fruits_in_hands, source);
        fruits_in_mixer_count = fruits_in_mixer_count + 1;
        operateAnimation('PLAY', getAnimations(mixer_place, false), null, null, 'LoopOnce', 1, function() {
            playSound(loadMedia_WebAudio('sounds/put_in_mixer.mp3'), false);
            if (fruits_in_hands && typeof fruits_in_hands == 'object' ? !Object.keys(fruits_in_hands).length : true) {
                operateAnimation('PLAY', 'mixer_cap', 10, 20, 'AUTO', 1, function() {
                    mixer_opened = false;
                }, false);
                playSound(loadMedia_WebAudio('sounds/mixer_closing.mp3'), false);
            }
        }, false);
    } else if ((fruits_in_mixer && typeof fruits_in_mixer == 'object' ? fruits_in_mixer.hasOwnProperty(mixer_place) : false) == true) {
        put_in_mixer(source);
    }
}

// isSoundPlaying puzzle
function isSoundPlaying(mediaElem) {
    if (!mediaElem)
        return false;
    return mediaElem.isPlaying();
}

// Describe this function...
function randomize_track() {
    current_track = 'music_' + String(mathRandomInt(1, 3));
    if (!isSoundPlaying(loadMedia_HTML5(['sounds/',current_track,'.mp3'].join('')))) {
        playSound(loadMedia_HTML5(['sounds/',current_track,'.mp3'].join('')), true);
    }
}

// stopSound puzzle
function stopSound(mediaElem) {
    const mediaElems = (Array.isArray(mediaElem) ? mediaElem : [mediaElem]).filter(elem => elem);
    mediaElems.forEach(mediaElem => {
        mediaElem.stop();
    });
}

// cloneObject puzzle
function cloneObject(objName, cloneMaterials, preserveGroups) {
    if (!objName)
        return;
    const obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    const objNew = obj.clone(); // recursive
    objNew.name = PzLib.generateUniqueObjectName(obj.name);

    // assign unique names for multi-material object meshes
    const objsM = objNew.resolveMultiMaterial();
    if (objNew != objsM[0])
        for (let i = 0; i < objsM.length; i++)
            objsM[i].name = objNew.name + 'MatMesh' + i;

    if (cloneMaterials) {
        objNew.traverse(o => {
            if (o.material) {
                o.material = o.material.clone();
            }
        });
    }

    if (preserveGroups) {
        const oldGroups = [];
        obj.traverse(o => {
            oldGroups.push(o.groupNames);
        });

        let i = 0;
        objNew.traverse(o => {
            o.groupNames.push(...oldGroups[i]);
            i++;
        });
    }

    appInstance.scene.add(objNew);

    // add object to cache now to increase performance
    _pGlob.objCache.set(objNew.name, objNew);

    return objNew.name;
}

// Describe this function...
function get_fruit(fruit, hand) {
    dictSet(fruits_in_hands, hand, cloneObject(fruit, false, false));
    snapToObject(dictGet(fruits_in_hands, hand), hand);
    if (VR_mode) {
        setObjTransform(dictGet(fruits_in_hands, hand), false, 'rotation', ['', 90, ''], false);
    } else {
        setObjTransform(dictGet(fruits_in_hands, hand), false, 'rotation', ['', 45, ''], false);
    }
    makeParent(dictGet(fruits_in_hands, hand), hand);
    playSound(loadMedia_WebAudio('sounds/picking.mp3'), false);
    if (mixer_opened == false) {
        playSound(loadMedia_WebAudio('sounds/mixer_opening.mp3'), false);
        operateAnimation('PLAY', 'mixer_cap', 0, 10, 'LoopOnce', 1, function() {
            mixer_opened = true;
        }, false);
    }
}

// distanceBetweenObjects puzzle
function getDistanceBetweenObjects(objName1, objName2) {
    if (!objName1 || !objName2)
        return;
    var obj1 = PzLib.getObjectByName(objName1);
    var obj2 = PzLib.getObjectByName(objName2);
    if (!obj1 || !obj2)
        return;
    return obj1.getWorldPosition(_pGlob.vec3Tmp).distanceTo(obj2.getWorldPosition(_pGlob.vec3Tmp2));
}

// xrSessionEvent puzzle
function xrSessionEvent(eventType, callback) {

    const eventHandler = function(event) {
        const ctrlObj = event.target;

        // set gamepad index to controller index
        _pGlob.gamepadIndex = appInstance.xrControllers.indexOf(ctrlObj);
        callback(event);

        // to cleanup XR controller rays/reticles
        if (event.type == 'disconnected') {
            _pGlob.objCache.clear();
        }
    }

    _pGlob.xrSessionCallbacks.push([eventType, eventHandler]);

    // register controller event here if executed after XR session acquisition
    if (_pGlob.xrSessionAcquired) {
        appInstance.xrControllers.forEach(function(controller) {
            PzLib.bindListener(controller, eventType, eventHandler);
        });
    }

}

// isAnimationPlaying puzzle
function isAnimationPlaying(animations) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];
    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (!animName)
            continue;
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (action && action.isRunning())
            return true;
    }
    return false;
}


/* VR LOGIC */
fruits_in_hands = {};
fruits_in_mixer = {};
fruits_in_mixer_count = 0;
mixing = false;
cup_full = false;
mixer_opened = false;
smoothie_hue = 0.5;

/* VR */
VR_mode = false;

/* INTERFACE */
createCSSRule('.enter-vr-button', ('position:absolute;' + '\n' +
'display:none;' + '\n' +
'width:240px;' + '\n' +
'height:40px;' + '\n' +
'text-align:center;' + '\n' +
'bottom:150px;' + '\n' +
'right:50%;' + '\n' +
'margin-right:-100px;' + '\n' +
'border-radius:20px;' + '\n' +
'color:white;' + '\n' +
'font-family: Verdana, sans-serif;' + '\n' +
'font-weight:bolt;' + '\n' +
'font-size: 20px;' + '\n' +
'line-height:2;' + '\n' +
'border:1px solid white;' + '\n' +
'cursor:pointer;' + '\n' +
'background-image:url(\'./img/vr-helm.svg\');' + '\n' +
'background-repeat: no-repeat;' + '\n' +
'background-size: 40px;' + '\n' +
'background-position: top 4px right 15px;' + '\n' +
'background-color:#00AEB2;'), false, '');
addHTMLElement('div', 'enter_vr_button', 'TO', ['CONTAINER'], false);
setHTMLElemAttribute('className', 'enter-vr-button', 'enter_vr_button', false);
setHTMLElemAttribute('innerHTML', 'ENTER VR', 'enter_vr_button', false);

checkVRMode(function() {
    setHTMLElemStyle('display', 'block', 'enter_vr_button', false);
}, function() {
    setHTMLElemStyle('display', 'none', 'enter_vr_button', false);
});

/* sounds */
sound_lock = true;
sound_on = false;
current_track = 'none';
volume(loadMedia_HTML5('sounds/environment.mp3'), 0.05);
volume(loadMedia_HTML5('sounds/music_1.mp3'), 0.5);
soundPositionalSpeaker(loadMedia_HTML5('sounds/music_1.mp3'), 'radio', 1, 1);
volume(loadMedia_HTML5('sounds/music_2.mp3'), 0.5);
soundPositionalSpeaker(loadMedia_HTML5('sounds/music_2.mp3'), 'radio', 1, 1);
volume(loadMedia_HTML5('sounds/music_3.mp3'), 0.5);
soundPositionalSpeaker(loadMedia_HTML5('sounds/music_3.mp3'), 'radio', 1, 1);
volume(loadMedia_WebAudio('sounds/smoothie_drinking.mp3'), 1);
volume(loadMedia_WebAudio('sounds/mixer_working.mp3'), 0.8);
soundPositionalSpeaker(loadMedia_WebAudio('sounds/mixer_working.mp3'), 'mixer', 1, 1);
volume(loadMedia_WebAudio('sounds/picking.mp3'), 0.6);
volume(loadMedia_WebAudio('sounds/voice_mixer_is_full.mp3'), 1);
volume(loadMedia_WebAudio('sounds/put_in_mixer.mp3'), 1.2);
soundPositionalSpeaker(loadMedia_WebAudio('sounds/put_in_mixer.mp3'), 'mixer', 1, 1);
volume(loadMedia_WebAudio('sounds/radio_button.mp3'), 0.7);
volume(loadMedia_WebAudio('sounds/mixer_opening.mp3'), 1);
soundPositionalSpeaker(loadMedia_WebAudio('sounds/mixer_opening.mp3'), 'mixer', 1, 1);
volume(loadMedia_WebAudio('sounds/mixer_closing.mp3'), 1);
soundPositionalSpeaker(loadMedia_WebAudio('sounds/mixer_closing.mp3'), 'mixer', 1, 1);

registerOnClick('mixer', false, false, [0,1,2], false, function(event) {
    if (fruits_in_mixer_count > 1 && mixing == false) {
        mixing = true;
        playSound(loadMedia_WebAudio('sounds/mixer_working.mp3'), false);
        operateAnimation('PLAY', 'mixer_razors', null, null, 'AUTO', 1, function() {}, false);
        operateAnimation('PLAY', 'mixer_fruits_base', null, null, 'LoopOnce', 1, function() {}, false);
        operateAnimation('PLAY', 'smoothie_in_mixer', 0, 140, 'LoopOnce', 1, function() {
            var i_list = fruits_in_mixer && typeof fruits_in_mixer == 'object' ? Object.keys(fruits_in_mixer) : [];
            for (var i_index in i_list) {
                let i = i_list[i_index];
                removeObject(dictGet(fruits_in_mixer, i));
                dictRemove(fruits_in_mixer, i);
            }
            fruits_in_mixer_count = 0;
            changeVis('smoothie_in_cup', true);
            operateAnimation('PLAY', 'smoothie_in_mixer', 140, 200, 'LoopOnce', 1, function() {
                mixing = false;
                changeVis('smoothie_in_mixer', false);
                smoothie_hue = 0.5;
            }, false);
            operateAnimation('PLAY', 'smoothie_in_cup', null, null, 'LoopOnce', 1, function() {
                cup_full = true;
            }, false);
        }, false);
        onAnimationFrameDo('smoothie_in_mixer', 40, function() {
            changeVis('smoothie_in_mixer', true);
        });
    }
}, function(event) {});

eventHTMLElem('click', 'enter_vr_button', false, function(event) {
    VR_INIT();
});

registerEveryFrame(function() {
    traverseControllers(function() {
        move_forward = -(getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '1') + getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '3'));
        move_side = getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '0') + getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '2');
        dir_vector_forward = getObjDirection(getActiveCamera(), 'HORIZONTAL');
        dir_vector_side = vectorMath(dir_vector_forward, 'ROTATE', createVector(0, 0, -90));
        dir_vector = vectorMath(vectorMath(dir_vector_forward, 'MULTIPLY', move_forward), 'ADD', vectorMath(dir_vector_side, 'MULTIPLY', move_side));
        move_speed = appInstance.elapsed * 1.5;
        dir_vector = vectorMath(dir_vector, 'MULTIPLY', move_speed);
        ray_cast_position = vectorMath(getObjTransform(xrCameraControlObject(), false, 'position', 'xyz'), 'ADD', dir_vector);
        setVectorValue(ray_cast_position, 'Z', 2);
        raycast_result = raycast(ray_cast_position, createVector(0, 0, -1), 'coliision', false);
        if (!!raycast_result.length) {
            setObjTransform(xrCameraControlObject(), false, 'position', dir_vector, true);
        }
    });
});

eventHTMLElem('click', ['WINDOW'], false, function(event) {
    if (sound_lock) {
        playSound(loadMedia_HTML5('sounds/environment.mp3'), true);
        randomize_track();
        sound_lock = false;
        sound_on = true;
        changeVis('icon_sound_on', true);
        changeVis('icon_sound_off', false);
    }
});

registerOnClick('radio', false, false, [0,1,2], false, function(event) {
    playSound(loadMedia_WebAudio('/sounds/radio_button.mp3'), false);
    if (sound_on == true) {
        stopSound(loadMedia_HTML5(['sounds/',current_track,'.mp3'].join('')));
        sound_on = false;
        changeVis('icon_sound_off', true);
        changeVis('icon_sound_on', false);
        current_track = 'none';
    } else {
        randomize_track();
        sound_on = true;
        changeVis('icon_sound_on', true);
        changeVis('icon_sound_off', false);
    }
}, function(event) {});

xrSessionEvent('squeezestart', function(event) {
    if (getDistanceBetweenObjects(xrControllerProp('OBJECT'), 'bananas') <= 0.5) {
        get_fruit('banana', xrControllerProp('OBJECT'));
    } else if (getDistanceBetweenObjects(xrControllerProp('OBJECT'), 'apples') <= 0.5) {
        get_fruit('apple', xrControllerProp('OBJECT'));
    } else if (getDistanceBetweenObjects(xrControllerProp('OBJECT'), 'oranges') <= 0.5) {
        get_fruit('orange', xrControllerProp('OBJECT'));
    }
});
xrSessionEvent('squeezeend', function(event) {
    if (getDistanceBetweenObjects(xrControllerProp('OBJECT'), 'mixer_trigger') <= 0.2 && mixing == false && !isAnimationPlaying('mixer_cap') && fruits_in_mixer_count < 4) {
        put_in_mixer(xrControllerProp('OBJECT'));
    } else if (fruits_in_mixer_count >= 4 && getDistanceBetweenObjects(xrControllerProp('OBJECT'), 'mixer_trigger') <= 0.2) {
        removeObject(dictGet(fruits_in_hands, xrControllerProp('OBJECT')));
        dictRemove(fruits_in_hands, xrControllerProp('OBJECT'));
        playSound(loadMedia_WebAudio('sounds/voice_mixer_is_full.mp3'), false);
        if ((fruits_in_hands && typeof fruits_in_hands == 'object' ? !Object.keys(fruits_in_hands).length : true) && mixer_opened) {
            playSound(loadMedia_WebAudio('sounds/mixer_closing.mp3'), false);
            operateAnimation('PLAY', 'mixer_cap', 10, 20, 'AUTO', 1, function() {
                mixer_opened = false;
            }, false);
        }
    } else {
        removeObject(dictGet(fruits_in_hands, xrControllerProp('OBJECT')));
        dictRemove(fruits_in_hands, xrControllerProp('OBJECT'));
        if ((fruits_in_hands && typeof fruits_in_hands == 'object' ? !Object.keys(fruits_in_hands).length : true) && mixer_opened) {
            playSound(loadMedia_WebAudio('sounds/mixer_closing.mp3'), false);
            operateAnimation('PLAY', 'mixer_cap', 10, 20, 'AUTO', 1, function() {
                mixer_opened = false;
            }, false);
        }
    }
});
registerOnClick('cup', false, false, [0,1,2], false, function(event) {
    if (cup_full == true) {
        operateAnimation('PLAY', 'smoothie_in_cup', 0, 60, 'LoopOnce', 1, function() {
            cup_full = false;
            changeVis('smoothie_in_cup', false);
        }, true);
        playSound(loadMedia_WebAudio('sounds/smoothie_drinking.mp3'), false);
    }
}, function(event) {});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
