/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.11.0
 * Tue, 23 Dec 2025 11:36:21 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = new Map();
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();
_pGlob.css3Objects = new WeakMap();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
        
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    function xrTraverseNonControllers(obj, callback) {
        if (obj.name.startsWith('XR_CONTROLLER_')) {
            return;
        }
    
        callback(obj);
    
        const children = obj.children;
        for (let i = 0, l = children.length; i < l; i++) {
            xrTraverseNonControllers(children[i], callback);
        }
    };
        
    function xrGetIntersections(controller) {
        controller.updateWorldMatrix(true, false);
    
        _pGlob.mat4Tmp.identity().extractRotation(controller.matrixWorld);
    
        const objList = [];
        xrTraverseNonControllers(appInstance.scene, obj => objList.push(obj));
    
        const raycaster = new v3d.Raycaster();
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(_pGlob.mat4Tmp);
    
        return raycaster.intersectObjects(objList, false);
    }
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function getObjectUUID(obj) {
        // auto-generated from a multi-material object, use parent UUID instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.uuid;
        } else {
            return obj.uuid;
        }
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        // COMPAT: <4.9.0, old engine, new puzzles
        const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable)
            objFound = _pGlob.objCache.get(objName);
    
        if (objFound && (isID ? objFound.uuid === objName : objFound.name === objName))
            return objFound;
    
        function findValidByName(obj, objName) {
            if ((isID ? obj.uuid === objName : obj.name === objName) && isObjectWorthProcessing(obj))
                return obj;
    
            for (let i = 0; i < obj.children.length; i++) {
                const child = obj.children[i];
                const object = findValidByName(child, objName);
                if (object !== null)
                    return object;
            }
    
            return null;
        }
    
        if (appInstance.scene) {
            objFound = findValidByName(appInstance.scene, objName);
            if (objFound && pGlobAvailable)
                _pGlob.objCache.set(objName, objFound);
        }
    
        return objFound;
    }
        
    function isObjectAmongObjects(objNameToCheck, objUUIDToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        // COMPAT: <4.10, when calling with 2 arguments
        if (Array.isArray(objUUIDToCheck)) {
            objNames = objUUIDToCheck;
            objUUIDToCheck = objNameToCheck;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            const objName = objNames[i];
    
            // COMPAT: < 4.10 (4.9), old engine, new puzzles
            const isID = v3d.MathUtils.checkUUID ? v3d.MathUtils.checkUUID(objName) : false;
    
            if ((isID ? objUUIDToCheck : objNameToCheck) === objName) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objName);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        // if parent referred by UUID, compare children also by UUID
                        if (isID ? (objUUIDToCheck === obj.children[j].uuid) : (objNameToCheck === obj.children[j].name)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function xrOnSelect(event) {
        if (!_pGlob.objClickInfo) {
            return;
        }
    
        const controller = event.target;
        const intersections = xrGetIntersections(controller);
    
        if (intersections.length > 0) {
            const intersection = intersections[0];
            const obj = intersection.object;
    
            _pGlob.objClickInfo.forEach(info => {
                const objName = getObjectName(obj);
                const objUUID = getObjectUUID(obj);
    
                // save the object for the pickedObject block
                _pGlob.pickedObject = info.useID ? objUUID : objName;
    
                const isPicked = obj && isObjectAmongObjects(objName, objUUID,
                        retrieveObjectNames(info.objSelector));
                info.callbacks[isPicked ? 0 : 1]();
            });
        } else {
            // missed
            _pGlob.objClickInfo.forEach(info => info.callbacks[1]());
        }
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function unbindListener(target, type, listener, optionsOrUseCapture) {
        const index = _pGlob.eventListeners.findIndex(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
        });
    
        if (index !== -1) {
            target.removeEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.splice(index, 1);
        }
    }
        
    function xrGetInputSource(controller) {
        if (controller && controller.userData.inputSource) {
            return controller.userData.inputSource;
        } else {
            return null;
        }
    };
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    const LIST_NONE = '<none>';

    return {
        getElement, getElements, xrGetIntersections, xrOnSelect,
        bindListener, getObjectName, isObjectAmongObjects, retrieveObjectNames,
        unbindListener, xrGetInputSource, transformCoordsSpace, getSceneCoordSystem,
        getObjectByName, transformEulerV3dToBlenderShortest, RotationInterface, LIST_NONE,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["VR_INIT"] = VR_INIT;

var prevStickMoved, VR_mode, visibility, move_forward, move_side, YY, dir_vector_forward, XX, dir_vector_side, dir_vector, move_speed, ray_cast_position, raycast_result;

// createCSSRule puzzle
function createCSSRule(cssRule, cssRuleCont, isParent, mediaRule) {
    var style = document.createElement('style');
    style.type = 'text/css';
    if (mediaRule) {
        style.innerHTML = `@media ${mediaRule} { ${cssRule} { ${cssRuleCont} } }`;
    } else {
        style.innerHTML = `${cssRule} { ${cssRuleCont} }`;
    }

    var styles = (isParent) ? parent.document.getElementsByTagName('head')[0] :
                              document.getElementsByTagName('head')[0];
    styles.appendChild(style)
}

// addHTMLElement puzzle
function addHTMLElement(elemType, id, mode, targetId, isParent) {
    const win = isParent ? window.parent : window;

    const elem = win.document.createElement(elemType);
    if (id !== '')
        elem.id = id;

    const targetElem = PzLib.getElement(targetId, isParent);
    if (targetElem instanceof win.Element) {
        switch (mode) {
            case 'TO':
                targetElem.appendChild(elem);
                break;
            case 'BEFORE':
                targetElem.insertAdjacentElement('beforebegin', elem);
                break;
            case 'AFTER':
                targetElem.insertAdjacentElement('afterend', elem);
                break;
        }

        _pGlob.htmlElements.add(elem);
    } else
        console.error('add HTML element puzzle: Invalid element "' + targetId + '"');
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// checkVRMode puzzle
function checkVRMode(availableCb, unAvailableCb) {
    v3d.Detector.checkWebXR('immersive-vr', availableCb, unAvailableCb);
}

// enterVRMode puzzle
function enterVRMode(refSpace, enterCb, exitCb, unAvailableCb) {

    var DEFAULT_DEPTH = 10;

    var _rayReticleDepth = [];
    var _hoveredObjects = [];

    function onControllerHover() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            var intersections = PzLib.xrGetIntersections(controller);

            if (intersections.length > 0) {
                var intersection = intersections[0];
                var obj = intersection.object;
                _rayReticleDepth[i] = intersection.distance;
            } else {
                var obj = null;
                _rayReticleDepth[i] = DEFAULT_DEPTH;
            }

            controller.children.forEach(function(child) {
                if (child.name.indexOf('_RAY') > -1) {
                    child.scale.z = _rayReticleDepth[i];
                } else if (child.name.indexOf('_RETICLE') > -1) {
                    // reduces crossing artefacts
                    child.position.z = -0.95 * _rayReticleDepth[i];
                }
            });

            var prevHovered = _hoveredObjects[i];
            var currHovered = obj ? PzLib.getObjectName(obj) : '';

            if (prevHovered == currHovered) {
                continue;
            }

            // first - all "out" callbacks, then - all "over"
            _pGlob.objHoverInfo.forEach(function(el) {
                if (PzLib.isObjectAmongObjects(prevHovered, PzLib.retrieveObjectNames(el.objSelector))) {
                    // ensure the correct value of the hoveredObject block
                    _pGlob.hoveredObject = prevHovered;
                    el.callbacks[1]();
                }
            });

            _pGlob.objHoverInfo.forEach(function(el) {
                if (PzLib.isObjectAmongObjects(currHovered, PzLib.retrieveObjectNames(el.objSelector))) {
                    // ensure the correct value of the hoveredObject block
                    _pGlob.hoveredObject = currHovered;
                    el.callbacks[0]();
                }
            });

            _hoveredObjects[i] = currHovered;
        }
    }

    switch (refSpace) {
        case 'SITTING':
            var referenceSpace = 'local-floor';
            break;
        case 'WALKING':
            var referenceSpace = 'unbounded';
            break;
        case 'ORIGIN':
            var referenceSpace = 'local';
            break;
        case 'ROOM':
            var referenceSpace = 'bounded-floor';
            break;
        case 'VIEWER':
            var referenceSpace = 'viewer';
            break;
        default:
            console.error('enter VR mode puzzle: Wrong VR reference space');
            return;
    }

    appInstance.initWebXR('immersive-vr', referenceSpace, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            // clicks
            PzLib.bindListener(controller, 'select', PzLib.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                PzLib.bindListener(controller, pair[0], pair[1]);
            });
        }

        // hovers
        if (_pGlob.objHoverInfo && _pGlob.objHoverInfo.length && appInstance.renderCallbacks.indexOf(onControllerHover) == -1)
            appInstance.renderCallbacks.push(onControllerHover);

        _pGlob.xrSessionAcquired = true;

        enterCb();

    }, unAvailableCb, function() {

        var controllers = appInstance.xrControllers;

        for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];

            PzLib.unbindListener(controller, 'select', PzLib.xrOnSelect);

            _pGlob.xrSessionCallbacks.forEach(function(pair) {
                PzLib.unbindListener(controller, pair[0], pair[1]);
            });
        }

        var cbIdx = appInstance.renderCallbacks.indexOf(onControllerHover);
        if (cbIdx != -1)
            appInstance.renderCallbacks.splice(cbIdx, 1);

        _pGlob.xrSessionAcquired = false;

        // to cleanup XR_CAMERA_CONTROL_OBJECT and XR controllers
        _pGlob.objCache.clear();

        exitCb();
    });
}

// Describe this function...
function VR_INIT() {
    enterVRMode('SITTING', function() {
        VR_mode = true;
    }, function() {
        VR_mode = false;
    }, function() {});
}

// xrControllerProp puzzle
function xrControllerProp(prop) {

    if (_pGlob.xrSessionAcquired) {
        var controller = appInstance.xrControllers[_pGlob.gamepadIndex || 0];
        var inputSource = PzLib.xrGetInputSource(controller);
    } else {
        var controller = undefined;
        var inputSource = undefined;
    }

    switch (prop) {
    case 'OBJECT':
        if (controller)
            return controller.name;
        else
            return '';

    case 'RAY_RETICLE':
        if (controller && controller.children.length)
            return controller.children[0].name;
        else
            return '';

    case 'HANDEDNESS':
        if (controller && inputSource)
            return inputSource.handedness;
        else
            return '';

    case 'TARGET_RAY_MODE':
        if (controller && inputSource)
            return inputSource.targetRayMode;
        else
            return '';

    case 'PROFILES':
        if (controller && inputSource)
            return inputSource.profiles;
        else
            return [];

    case 'GAMEPAD_INDEX':
        if (controller && inputSource && inputSource.gamepad)
            return _pGlob.gamepadIndex || 0;
        else
            return 0;
    }

}

// getGamepadProp puzzle
function getGamepadProp(index, prop, controlIndex) {

    if (_pGlob.xrSessionAcquired) {
        var controller = appInstance.xrControllers[index];

        if (controller && controller.userData.inputSource &&
                controller.userData.inputSource.gamepad)
            var gamepad = controller.userData.inputSource.gamepad;
        else
            var gamepad = undefined;

    } else {
        var gamepad = navigator.getGamepads()[index];
    }

    switch (prop) {
    case 'AXIS':
        if (gamepad)
            return (gamepad.axes[controlIndex] || 0);
        else
            return 0;

    case 'BUTTON':
        if (gamepad) {
            var button = gamepad.buttons[controlIndex];

            if (button)
                return button.pressed;
            else
                return false;
        } else {
            return false;
        }

    case 'ANALOG_BUTTON':
        if (gamepad) {
            var button = gamepad.buttons[controlIndex];

            if (button)
                return button.value;
            else
                return 0.0;
        } else {
            return 0.0;
        }

    case 'ID':
        if (gamepad)
            return gamepad.id;
        else
            return '';

    case 'CONNECTION_STATUS':
        if (gamepad)
            return gamepad.connected;
        else
            return false;

    case 'TIMESTAMP':
        if (gamepad)
            return gamepad.timestamp;
        else
            return 0.0;

    case 'MAPPING':
        if (gamepad)
            return gamepad.mapping;
        else
            return '';

    case 'DEBUG_INFO':
        if (gamepad) {

            var axes = gamepad.axes;
            var axesValues = []

            for (var i = 0; i < axes.length; i++) {
                axesValues.push(Math.round(axes[i] * 1000) / 1000);
            }

            var buttons = gamepad.buttons;
            var btnsPressed = [];
            var btnsValues = [];

            for (var i = 0; i < buttons.length; i++) {
                btnsPressed.push(buttons[i].pressed ? '☑' : '☐');
                btnsValues.push(Math.round(buttons[i].value * 1000) / 1000);
            }

            return 'Index: ' + index + '\n' +
                   'Connected: ' + (gamepad.connected ? 'Yes' : 'No') + '\n' +
                   'ID: ' + (gamepad.id ? gamepad.id : 'N/A') + '\n' +
                   'Axes: ' + String(axesValues) + '\n' +
                   'Buttons: ' + String(btnsPressed) + '\n' +
                   'Analog Buttons: ' + String(btnsValues) + '\n' +
                   'Timestamp: ' + (gamepad.timestamp ? gamepad.timestamp.toFixed(3) : 0);
        } else {
            return 'Gamepad not available';
        }
    }

}

// getActiveCamera puzzle
function getActiveCamera() {
    var camera = appInstance.getCamera();
    return camera.name;
}

// getObjDirection puzzle
function getObjDirection(objName, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var dir = obj.getWorldDirection(_pGlob.vec3Tmp);

    var coordSystem = PzLib.getSceneCoordSystem();
    PzLib.transformCoordsSpace(dir, 'Y_UP_RIGHT', coordSystem);

    switch (coord) {
    case 'X':
        return dir.x;
    case 'Y':
        return dir.y;
    case 'Z':
        return dir.z;
    case 'XYZ':
        return dir.toArray();
    case 'HORIZONTAL':
        switch (coordSystem) {
        case 'Y_UP_RIGHT':
            dir.y = 0;
            dir.normalize();
            return [dir.x, 0, dir.z];
        default:
            dir.z = 0;
            dir.normalize();
            return [dir.x, dir.y, 0];
        }
    default:
        console.error("get object direction puzzle: Wrong coords");
        return;
    }
};

// createVector puzzle
function createVector(x, y, z) {
    return [x, y, z];
};

// vectorMath puzzle
function vectorMath(vec1, operation, vec2) {

    vec1 = _pGlob.vec3Tmp.fromArray(vec1);

    if (Array.isArray(vec2)) {
        vec2 = _pGlob.vec3Tmp2.fromArray(vec2);
    } else if (['ADD', 'SUBTRACT', 'MULTIPLY', 'DIVIDE'].indexOf(operation) > -1) {
        vec2 = _pGlob.vec3Tmp2.setScalar(vec2);
    } else {
        console.error('vector math puzzle: Invalid argument, scalars are not allowed for ' + operation.toLowerCase() + ' operation');
        return;
    }

    switch (operation) {
    case 'ADD':
        return vec1.add(vec2).toArray();
    case 'SUBTRACT':
        return vec1.sub(vec2).toArray();
    case 'MULTIPLY':
        return vec1.multiply(vec2).toArray();
    case 'DIVIDE':
        return vec1.divide(vec2).toArray();
    case 'DOT':
        return vec1.dot(vec2);
    case 'CROSS':
        return vec1.cross(vec2).toArray();
    case 'ROTATE':
        var euler = _pGlob.eulerTmp;
        vec2.multiplyScalar(Math.PI/180);
        return vec1.applyEuler(euler.setFromVector3(vec2)).toArray();
    default:
        console.error('vector math puzzle: Wrong operation');
        return;
    }
};

// xrCameraControlObject puzzle
function xrCameraControlObject() {
    const camera = appInstance.getCamera();
    if (camera && camera.parent && !camera.parent.isScene)
        return camera.parent.name;
    else
        return '';
}

// getObjTransform puzzle
function getObjTransform(objName, isWorldSpace, mode, coord) {
    if (!objName)
        return;
    var obj = PzLib.getObjectByName(objName);
    if (!obj)
        return;

    var coordSystem = PzLib.getSceneCoordSystem();

    var transformVal;

    if (isWorldSpace && obj.parent) {
        if (mode === 'position') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldPosition(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'rotation') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldEuler(_pGlob.eulerTmp, 'XYZ'), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        } else if (mode === 'scale') {
            transformVal = PzLib.transformCoordsSpace(
                    obj.getWorldScale(_pGlob.vec3Tmp), 'Y_UP_RIGHT',
                    coordSystem, mode === 'scale');
        }

    } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
        transformVal = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                _pGlob.eulerTmp);

    } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
        // Maya coordinates
        // Use separate rotation interface to fix ambiguous rotations for Maya,
        // might as well do the same for Blender/Max.

        var rotUI = PzLib.RotationInterface.initObject(obj);
        transformVal = rotUI.getUserRotation(_pGlob.eulerTmp);

    } else {
        transformVal = PzLib.transformCoordsSpace(obj[mode].clone(),
                'Y_UP_RIGHT', coordSystem, mode === 'scale');
    }

    if (mode === 'rotation') {
        transformVal.x = v3d.MathUtils.radToDeg(transformVal.x);
        transformVal.y = v3d.MathUtils.radToDeg(transformVal.y);
        transformVal.z = v3d.MathUtils.radToDeg(transformVal.z);
    }

    if (coord == 'xyz') {
        // remove order component for Euler vectors
        return transformVal.toArray().slice(0, 3);
    } else {
        return transformVal[coord];
    }
}

// setVectorValue puzzle
function setVectorValue(vector, valueName, value) {
    switch (valueName) {
    case 'X':
        vector[0] = value;
        break;
    case 'Y':
        vector[1] = value;
        break;
    case 'Z':
        vector[2] = value;
        break;
    case 'LENGTH':
        _pGlob.vec3Tmp.fromArray(vector).setLength(value).toArray(vector);
        break;
    }
}

// raycast puzzle
const _raycastRaycasterTmp = new v3d.Raycaster();

function raycast(fromPosObj, dir, intersectObjsSelector, onlyVisible) {

    if (!fromPosObj || !dir) {
        console.error('raycast puzzle: Missing input');
        return [];
    }

    let from;

    if (Array.isArray(fromPosObj)) {
        from = _pGlob.vec3Tmp.fromArray(fromPosObj);
        from = PzLib.transformCoordsSpace(from, PzLib.getSceneCoordSystem(),
                'Y_UP_RIGHT');
    } else {
        const posObj = PzLib.getObjectByName(fromPosObj);
        if (!posObj) {
            console.error('raycast puzzle: Raycast object not found');
            return []
        }
        from = posObj.getWorldPosition(_pGlob.vec3Tmp);
    }

    dir = _pGlob.vec3Tmp2.fromArray(dir);
    dir = PzLib.transformCoordsSpace(dir, PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');

    let objs;

    if (intersectObjsSelector === '' || intersectObjsSelector === PzLib.LIST_NONE) {

        objs = [appInstance.scene];

    } else {

        objs = PzLib.retrieveObjectNames(intersectObjsSelector).map(function(objName) {
            return PzLib.getObjectByName(objName);
        });

    }

    if (objs.length) {

        const raycaster = _raycastRaycasterTmp;

        raycaster.params.checkVisibility = onlyVisible;
        raycaster.set(from, dir);
        const intersects = raycaster.intersectObjects(objs);

        for (let i = 0; i < intersects.length; i++) {
            const int = intersects[i];

            int.object = PzLib.getObjectName(int.object);
            int.point = PzLib.transformCoordsSpace(int.point, 'Y_UP_RIGHT',
                    PzLib.getSceneCoordSystem()).toArray();

            if (int.face) {
                int.normal = PzLib.transformCoordsSpace(int.face.normal,
                        'Y_UP_RIGHT', PzLib.getSceneCoordSystem()).toArray();
            }

            if (int.uv) {
                int.uv = int.uv.toArray();
            }

            delete int.face;
            delete int.faceIndex;

        }

        return intersects;
    } else {
        return [];
    }
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset) {
    const x = vector[0];
    const y = vector[1];
    const z = vector[2];

    if (isNaN(x) || isNaN(y) || isNaN(z)) {
        console.error('set transform puzzle: Invalid transform');
        return;
    }

    const objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    const inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''), Number(z !== ''));
    const coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    const coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (let i = 0; i < objNames.length; i++) {

        const objName = objNames[i];
        if (!objName) continue;

        const obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            const euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            const rotUI = PzLib.RotationInterface.initObject(obj);
            const euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);
        }

        obj.updateWorldMatrix(false, true);
    }

}

// isObjectVisible puzzle
function isObjectVisible(objSelector) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        if (obj.visible)
            return true;
    }
    return false;
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// traverseControllers puzzle
function traverseControllers(callback) {
    if (_pGlob.xrSessionAcquired) {
        for (var i = 0; i < appInstance.xrControllers.length; i++) {

            var controller = appInstance.xrControllers[i];
            var inputSource = PzLib.xrGetInputSource(controller);

            if (controller && inputSource) {
                _pGlob.gamepadIndex = i;
                callback();
            }
        }
    }
}

// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == 'function') {
        appInstance.renderCallbacks.push(callback);
        if (PL.editorRenderCallbacks)
            PL.editorRenderCallbacks.push([appInstance, callback]);
    }
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}


/* VR */
VR_mode = false;

/* INTERFACE */
createCSSRule('.enter-vr-button', ('position:absolute;' + '\n' +
'display:none;' + '\n' +
'width:240px;' + '\n' +
'height:40px;' + '\n' +
'text-align:center;' + '\n' +
'bottom:150px;' + '\n' +
'right:50%;' + '\n' +
'margin-right:-100px;' + '\n' +
'border-radius:20px;' + '\n' +
'color:white;' + '\n' +
'font-family: Verdana, sans-serif;' + '\n' +
'font-weight:bolt;' + '\n' +
'font-size: 20px;' + '\n' +
'line-height:2;' + '\n' +
'border:1px solid white;' + '\n' +
'cursor:pointer;' + '\n' +
'background-image:url(\'./img/vr-helm.svg\');' + '\n' +
'background-repeat: no-repeat;' + '\n' +
'background-size: 40px;' + '\n' +
'background-position: top 4px right 15px;' + '\n' +
'background-color:#00AEB2;'), false, '');
addHTMLElement('div', 'enter_vr_button', 'TO', ['CONTAINER'], false);
setHTMLElemAttribute('className', 'enter-vr-button', 'enter_vr_button', false);
setHTMLElemAttribute('innerHTML', 'ENTER VR', 'enter_vr_button', false);

checkVRMode(function() {
    setHTMLElemStyle('display', 'block', 'enter_vr_button', false);
}, function() {
    setHTMLElemStyle('display', 'none', 'enter_vr_button', false);
});

prevStickMoved = false;
visibility = true;
registerEveryFrame(function() {
    traverseControllers(function() {
        if ((_pGlob.gamepadIndex || 0) == 0) {
            move_forward = -(getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '1') + getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '3'));
            move_side = getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '0') + getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'AXIS', '2');
            dir_vector_forward = getObjDirection(getActiveCamera(), 'HORIZONTAL');
            dir_vector_side = vectorMath(dir_vector_forward, 'ROTATE', createVector(0, 0, -90));
            dir_vector = vectorMath(vectorMath(dir_vector_forward, 'MULTIPLY', move_forward), 'ADD', vectorMath(dir_vector_side, 'MULTIPLY', move_side));
            move_speed = appInstance.elapsed * 1.5;
            dir_vector = vectorMath(dir_vector, 'MULTIPLY', move_speed);
            ray_cast_position = vectorMath(getObjTransform(xrCameraControlObject(), false, 'position', 'xyz'), 'ADD', dir_vector);
            setVectorValue(ray_cast_position, 'Z', 2);
            raycast_result = raycast(ray_cast_position, createVector(0, 0, -1), 'coliision', false);
            if (!!raycast_result.length) {
                setObjTransform(xrCameraControlObject(), false, 'position', dir_vector, true);
            }
        }
        if ((_pGlob.gamepadIndex || 0) == 1) {
            YY = getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'BUTTON', '0');
            XX = getGamepadProp(xrControllerProp('GAMEPAD_INDEX'), 'BUTTON', '2');
            if ((Math.abs(YY) > 0.5 || Math.abs(XX) > 0.5) && !prevStickMoved) {
                prevStickMoved = !prevStickMoved;
                if (isObjectVisible('control')) {
                    changeVis('control', false);
                } else {
                    changeVis('control', true);
                }
                prevStickMoved = true;
            } else if (Math.abs(YY) < 0.5 && Math.abs(XX) < 0.5) {
                prevStickMoved = false;
            }
        }
    });
});

eventHTMLElem('click', 'enter_vr_button', false, function(event) {
    VR_INIT();
});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
